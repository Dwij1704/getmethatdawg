#!/bin/bash

# getmethatdawg - Zero-config deploy for Python agents
# No flyctl dependency version - uses pre-authenticated container

set -euo pipefail

# Set GETMETHATDAWG_HOME if not already set
if [[ -z "${GETMETHATDAWG_HOME:-}" ]]; then
    GETMETHATDAWG_HOME="$(dirname "$(dirname "$(realpath "$0")")")"
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}ℹ${NC} $1"
}

log_success() {
    echo -e "${GREEN}✓${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}⚠${NC} $1"
}

log_error() {
    echo -e "${RED}✗${NC} $1"
}

# Check dependencies (only Docker needed now!)
check_dependencies() {
    local deps_ok=true
    
    if ! command -v docker &> /dev/null; then
        log_error "Docker is required but not installed. Please install Docker."
        deps_ok=false
    fi
    
    if ! docker info &> /dev/null; then
        log_error "Docker is not running. Please start Docker."
        deps_ok=false
    fi
    
    if [[ "$deps_ok" == false ]]; then
        exit 1
    fi
}

# Show usage
show_usage() {
    cat << EOF
getmethatdawg - Zero-config deploy for Python agents

Usage:
    getmethatdawg deploy <python_file>              Deploy a Python file as a web service
    getmethatdawg deploy <python_file> --auto-detect  Deploy with auto-detection (no decorators needed)
    getmethatdawg --help                            Show this help message
    getmethatdawg --version                         Show version information

Examples:
    getmethatdawg deploy my_agent.py                Deploy my_agent.py to the cloud
    getmethatdawg deploy story_agent.py --auto-detect   Auto-detect endpoints without decorators
    
The Python file can use the getmethatdawg SDK:
    import getmethatdawg
    
    @getmethatdawg.expose(method="GET", path="/hello")
    def greet(name: str = "world"):
        return {"msg": f"Hello {name}"}

OR with auto-detection, just write regular Python functions:
    def greet(name: str = "world"):
        return {"msg": f"Hello {name}"}

Requirements:
    - Docker (only dependency!)
    - No flyctl installation needed
    - No Fly.io account setup required

EOF
}

# Show version
show_version() {
    echo "getmethatdawg version 0.0.1-no-flyctl"
    echo "Zero-config deploy for Python agents"
    echo "No flyctl dependency version"
}

# Deploy function using pre-authenticated container
deploy_python_file() {
    local python_file="$1"
    local auto_detect_arg="${2:-}"
    local abs_python_file="$(realpath "$python_file")"
    
    # Validate input file
    if [[ ! -f "$abs_python_file" ]]; then
        log_error "File '$python_file' not found"
        exit 1
    fi
    
    if [[ ! "$abs_python_file" =~ \.py$ ]]; then
        log_error "File '$python_file' is not a Python file"
        exit 1
    fi
    
    log_info "Deploying $python_file..."
    log_info "Using pre-authenticated builder (no flyctl needed!)"
    
    # Create temporary directory for build output
    local temp_dir="$(mktemp -d)"
    local output_dir="$temp_dir/out"
    mkdir -p "$output_dir"
    
    # Cleanup function
    cleanup() {
        if [[ -n "${temp_dir:-}" ]] && [[ -d "${temp_dir:-}" ]]; then
            rm -rf "$temp_dir"
        fi
    }
    trap cleanup EXIT
    
    # Use the pre-authenticated builder container
    log_info "Using authenticated builder container..."
    
    # Container image (prioritize GitHub Container Registry)
    local builder_image="ghcr.io/dwij1704/getmethatdawg-builder:authenticated"
    
    # Check if we need to pull the latest image
    if ! docker image inspect "$builder_image" &> /dev/null; then
        log_info "Pulling authenticated builder container..."
        if ! docker pull "$builder_image" 2>/dev/null; then
            log_warning "Failed to pull from GitHub Container Registry, trying Docker Hub..."
            builder_image="getmethatdawg/builder:authenticated"
            docker pull "$builder_image"
        fi
    fi
    
    # Check if auto-detect flag is passed
    auto_detect_flag=""
    if [[ "$auto_detect_arg" == "--auto-detect" ]]; then
        auto_detect_flag="--auto-detect"
        log_info "Auto-detection mode enabled"
    fi
    
    # Check for additional files in the same directory
    local source_dir="$(dirname "$abs_python_file")"
    local requirements_file="$source_dir/requirements.txt"
    local env_file="$source_dir/.env"
    local docker_volumes="-v $abs_python_file:/tmp/source.py:ro -v $output_dir:/tmp/out"
    
    if [[ -f "$requirements_file" ]]; then
        log_info "Found custom requirements.txt, including in deployment"
        docker_volumes="$docker_volumes -v $requirements_file:/tmp/requirements.txt:ro"
    fi
    
    if [[ -f "$env_file" ]]; then
        log_info "Found .env file, including for secrets management"
        docker_volumes="$docker_volumes -v $env_file:/tmp/.env:ro"
    fi
    
    # Run the pre-authenticated builder container
    log_info "Building and deploying with authenticated container..."
    
    # Create a deployment script that will run inside the container
    local deploy_script="$output_dir/deploy-script.sh"
    cat > "$deploy_script" << 'EOF'
#!/bin/bash
set -euo pipefail

echo "🔧 Building deployment artifacts..."
getmethatdawg-builder /tmp/source.py "$1" $2

echo "📁 Changing to build output directory..."
cd /tmp/out

echo "🚀 Starting deployment to Fly.io..."

# Get app name from the parameter
APP_NAME="$1"

# Check if fly app exists, if not create it
if ! flyctl apps list | grep -q "$APP_NAME"; then
    echo "📱 Creating new Fly.io app: $APP_NAME"
    flyctl apps create "$APP_NAME" --generate-name || true
fi

# Deploy the app (check for secrets script first)
if [[ -f "deploy-with-secrets.sh" ]]; then
    echo "🔐 Deploying with secrets management..."
    chmod +x deploy-with-secrets.sh
    ./deploy-with-secrets.sh
else
    echo "🚀 Deploying without secrets..."
    flyctl deploy --remote-only --config fly.toml --dockerfile Dockerfile
fi

echo "✅ Deployment completed successfully!"

# Get the app URL
APP_URL=$(flyctl status --app "$APP_NAME" | grep "Hostname" | awk '{print $2}' | head -1 || echo "$APP_NAME.fly.dev")
echo "🌐 App URL: https://$APP_URL"

# Show endpoints
echo "📡 Available endpoints:"
echo "  GET  https://$APP_URL/ (health check)"

# Parse endpoints from generated flask app (basic parsing)
if [[ -f "/tmp/out/flask_app.py" ]]; then
    grep -E "@app\.route\(" "/tmp/out/flask_app.py" | while read -r line; do
        if [[ "$line" =~ @app\.route\(\'([^\']+)\',.*methods=\[\'([^\']+)\' ]]; then
            path="${BASH_REMATCH[1]}"
            method="${BASH_REMATCH[2]}"
            echo "  ${method}  https://$APP_URL$path"
        fi
    done
fi
EOF
    chmod +x "$deploy_script"
    
    # Run the container with the deployment script, streaming output in real-time
    if docker run --rm \
        $docker_volumes \
        -v "$deploy_script:/tmp/deploy.sh:ro" \
        "$builder_image" \
        /tmp/deploy.sh "$(basename "$python_file" .py | tr '_' '-')" "$auto_detect_flag"
    then
        log_success "🎉 Deployment completed successfully!"
    else
        log_error "❌ Deployment failed"
        exit 1
    fi
    log_info "If this is a new deployment, it may take a few minutes to become available"
}

# Main function
main() {
    case "${1:-}" in
        deploy)
            if [[ -z "${2:-}" ]]; then
                log_error "Please specify a Python file to deploy"
                show_usage
                exit 1
            fi
            check_dependencies
            deploy_python_file "$2" "${3:-}"
            ;;
        --help|-h)
            show_usage
            ;;
        --version|-v)
            show_version
            ;;
        "")
            log_error "No command specified"
            show_usage
            exit 1
            ;;
        *)
            log_error "Unknown command: $1"
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@" 