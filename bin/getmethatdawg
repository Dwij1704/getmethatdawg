#!/bin/bash

# getmethatdawg - Zero-config deploy for Python agents
# Supports both regular (flyctl) and pre-authenticated modes

set -euo pipefail

# Set GETMETHATDAWG_HOME if not already set
if [[ -z "${GETMETHATDAWG_HOME:-}" ]]; then
    GETMETHATDAWG_HOME="$(dirname "$(dirname "$(realpath "$0")")")"
fi

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}‚Ñπ${NC} $1"
}

log_success() {
    echo -e "${GREEN}‚úì${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}‚ö†${NC} $1"
}

log_error() {
    echo -e "${RED}‚úó${NC} $1"
}

# Check dependencies for regular mode
check_dependencies_regular() {
    local deps_ok=true
    
    if ! command -v docker &> /dev/null; then
        log_error "Docker is required but not installed. Please install Docker."
        deps_ok=false
    fi
    
    if ! command -v flyctl &> /dev/null; then
        log_error "flyctl is required but not installed. Please install flyctl."
        deps_ok=false
    fi
    
    if ! docker info &> /dev/null; then
        log_error "Docker is not running. Please start Docker."
        deps_ok=false
    fi
    
    if [[ "$deps_ok" == false ]]; then
        exit 1
    fi
}

# Check dependencies for pre-auth mode (Docker only)
check_dependencies_preauth() {
    local deps_ok=true
    
    if ! command -v docker &> /dev/null; then
        log_error "Docker is required but not installed. Please install Docker."
        deps_ok=false
    fi
    
    if ! docker info &> /dev/null; then
        log_error "Docker is not running. Please start Docker."
        deps_ok=false
    fi
    
    if [[ "$deps_ok" == false ]]; then
        exit 1
    fi
}

# Interactive function to create requirements.txt if missing
prompt_create_requirements() {
    local source_dir="$1"
    local python_file="$2"
    local requirements_file="$source_dir/requirements.txt"
    
    if [[ ! -f "$requirements_file" ]]; then
        log_warning "No requirements.txt found in $(basename "$source_dir")"
        echo "ü§î Would you like to auto-generate a requirements.txt file?"
        echo "   This will analyze your Python file for imports and create a basic requirements.txt"
        echo ""
        read -p "   Generate requirements.txt? (y/N): " -n 1 -r
        echo ""
        
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log_info "Analyzing Python imports..."
            
            # Extract imports from Python file
            local imports=$(python3 -c "
import ast
import sys

try:
    with open('$python_file', 'r') as f:
        tree = ast.parse(f.read())
    
    imports = set()
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                imports.add(alias.name.split('.')[0])
        elif isinstance(node, ast.ImportFrom):
            if node.module:
                imports.add(node.module.split('.')[0])
    
    # Filter out standard library modules
    stdlib_modules = {'os', 'sys', 'json', 'datetime', 'time', 'random', 'math', 're', 'collections', 'functools', 'itertools', 'pathlib', 'typing', 'uuid', 'hashlib', 'base64', 'urllib', 'http', 'socket', 'threading', 'multiprocessing', 'asyncio', 'logging', 'unittest', 'argparse', 'configparser', 'csv', 'sqlite3', 'pickle', 'tempfile', 'shutil', 'glob', 'fnmatch', 'tarfile', 'zipfile', 'gzip', 'zlib', 'email', 'mimetypes', 'html', 'xml', 'io', 'struct', 'codecs', 'locale', 'calendar', 'heapq', 'bisect', 'array', 'weakref', 'copy', 'pprint', 'reprlib', 'enum', 'decimal', 'fractions', 'statistics', 'string', 'textwrap', 'unicodedata', 'stringprep', 'readline', 'rlcompleter', 'warnings', 'contextlib', 'abc', 'atexit', 'traceback', 'gc', 'inspect', 'site', 'imp', 'importlib', 'keyword', 'pkgutil', 'modulefinder', 'runpy', 'types', 'builtins'}
    
    third_party = [imp for imp in imports if imp not in stdlib_modules and not imp.startswith('_')]
    
    for imp in sorted(third_party):
        print(imp)
except Exception as e:
    print(f'# Error analyzing imports: {e}', file=sys.stderr)
" 2>/dev/null)
            
            # Create requirements.txt
            if [[ -n "$imports" ]]; then
                echo "# Auto-generated requirements.txt" > "$requirements_file"
                echo "# Review and update versions as needed" >> "$requirements_file"
                echo "" >> "$requirements_file"
                while IFS= read -r line; do
                    if [[ -n "$line" && ! "$line" =~ ^# ]]; then
                        echo "$line" >> "$requirements_file"
                    fi
                done <<< "$imports"
                
                log_success "Created requirements.txt with detected packages"
                echo "üìù Please review $requirements_file and add version constraints if needed"
            else
                echo "# Add your Python dependencies here" > "$requirements_file"
                echo "# Example:" >> "$requirements_file"
                echo "# flask>=2.0.0" >> "$requirements_file"
                echo "# requests>=2.25.0" >> "$requirements_file"
                log_success "Created empty requirements.txt template"
            fi
            echo ""
        else
            log_info "Skipping requirements.txt creation"
            echo "üí° Tip: Add a requirements.txt file to ensure your dependencies are installed correctly"
            echo ""
        fi
    fi
}

# Interactive function to create .env file if missing
prompt_create_env() {
    local source_dir="$1"
    local env_file="$source_dir/.env"
    
    if [[ ! -f "$env_file" ]]; then
        log_warning "No .env file found in $(basename "$source_dir")"
        echo "üîê Would you like to create a .env file for environment variables?"
        echo "   This is useful for API keys, configuration settings, etc."
        echo ""
        read -p "   Create .env file? (y/N): " -n 1 -r
        echo ""
        
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            # Check if template exists
            if [[ -f "examples/.env.template" ]]; then
                cp "examples/.env.template" "$env_file"
                log_success "Created .env file from template"
                echo "üìù Please edit $env_file and add your actual values"
            else
                cat > "$env_file" << 'EOF'
# Environment Variables
# Add your API keys and configuration here

# Example API keys (uncomment and add your values)
# OPENAI_API_KEY=your_openai_api_key_here
# ANTHROPIC_API_KEY=your_anthropic_api_key_here

# Example configuration
# DEBUG=false
# LOG_LEVEL=info
EOF
                log_success "Created .env file template"
                echo "üìù Please edit $env_file and add your environment variables"
            fi
            echo ""
        else
            log_info "Proceeding without .env file"
            echo "üí° Tip: Create a .env file to securely manage API keys and configuration"
            echo "   You can add one later and redeploy to include environment variables"
            echo ""
        fi
    fi
}

# Function to preview endpoints before deployment
preview_endpoints() {
    local python_file="$1"
    local auto_detect="$2"
    
    if [[ "$auto_detect" != "--auto-detect" ]]; then
        return 0  # Skip preview if not using auto-detect
    fi
    
    log_info "Analyzing endpoints..."
    
    # Run a quick Python analysis to show function signatures
    local preview_output=$(python3 -c "
import ast
import inspect
import sys

try:
    with open('$python_file', 'r') as f:
        content = f.read()
        tree = ast.parse(content)
    
    functions = []
    for node in ast.walk(tree):
        if isinstance(node, ast.FunctionDef) and not node.name.startswith('_'):
            # Determine HTTP method based on function characteristics
            args = [arg.arg for arg in node.args.args]
            arg_count = len(args)
            
                         # Simple heuristic: functions with multiple complex params are POST
             if arg_count > 1 or any('data' in arg.lower() or 'request' in arg.lower() or 'body' in arg.lower() for arg in args):
                 method = 'POST'
                 endpoint = '/' + node.name.replace('_', '-')
             else:
                 method = 'GET'
                 query_params = [arg + '=' for arg in args] if args else []
                 endpoint = '/' + node.name.replace('_', '-') + ('?' + '&'.join(query_params) if query_params else '')
            
            # Get function signature for display
            arg_strs = []
            for i, arg in enumerate(node.args.args):
                if i < len(node.args.defaults):
                    default_idx = i - (len(node.args.args) - len(node.args.defaults))
                    if default_idx >= 0:
                        arg_strs.append(f'{arg.arg}=default')
                    else:
                        arg_strs.append(arg.arg)
                else:
                    arg_strs.append(arg.arg)
            
                                      signature = '(' + ', '.join(arg_strs) + ')'
            functions.append((method, endpoint, signature, node.name))
    
         if functions:
         for method, endpoint, signature, func_name in functions:
             print('   ' + method.ljust(4) + ' ' + endpoint.ljust(30) + ' # ' + func_name + signature)
     else:
         print('   No public functions found (functions starting with _ are ignored)')
        
 except Exception as e:
     print('   Error analyzing file: ' + str(e), file=sys.stderr)
" 2>/dev/null)
    
    if [[ -n "$preview_output" ]]; then
        echo ""
        echo "üöÄ Deployment Preview"
        echo "===================="
        echo ""
        echo "üì± App Name: $(basename "$python_file" .py | tr '_' '-')"
        echo "üåê URL: https://$(basename "$python_file" .py | tr '_' '-').fly.dev"
        echo ""
        echo "üì° Detected Endpoints:"
        echo "$preview_output"
        echo ""
        
        local source_dir="$(dirname "$(realpath "$python_file")")"
        local env_file="$source_dir/.env"
        local requirements_file="$source_dir/requirements.txt"
        
        if [[ -f "$env_file" ]]; then
            local env_count=$(grep -c "^[A-Z_][A-Z0-9_]*=" "$env_file" 2>/dev/null || echo "0")
            echo "üîê Environment Variables: $env_count found"
        else
            echo "üîê Environment Variables: None"
        fi
        
        if [[ -f "$requirements_file" ]]; then
            local dep_count=$(grep -v "^#" "$requirements_file" | grep -v "^$" | wc -l 2>/dev/null || echo "0")
            dep_count=$((dep_count))
            echo "üì¶ Dependencies: $dep_count packages"
        else
            echo "üì¶ Dependencies: Using Python standard library only"
        fi
        
        echo ""
        read -p "ü§î Proceed with deployment? (Y/n): " -n 1 -r
        echo ""
        
        if [[ $REPLY =~ ^[Nn]$ ]]; then
            log_info "Deployment cancelled by user"
            exit 0
        fi
    else
        echo ""
        echo "‚ö†Ô∏è  Could not preview endpoints"
        echo "   Continuing with deployment..."
        echo ""
    fi
}

# Show usage
show_usage() {
    cat << EOF
getmethatdawg - Zero-config deploy for Python agents

Usage:
    getmethatdawg deploy <python_file>                       Deploy using flyctl (default)
    getmethatdawg deploy <python_file> --auto-detect         Deploy with auto-detection using flyctl
    getmethatdawg deploy <python_file> --pre-auth            Deploy using pre-authenticated container
    getmethatdawg deploy <python_file> --auto-detect --pre-auth  Auto-detect with pre-auth
    getmethatdawg --help                                     Show this help message
    getmethatdawg --version                                  Show version information

Deployment Modes:
    Default Mode (requires flyctl):
        - Uses your local flyctl installation and authentication
        - Requires: Docker + flyctl + Fly.io account setup
        - Full control over deployments

    Pre-authenticated Mode (--pre-auth):
        - Uses pre-authenticated container with embedded credentials
        - Requires: Docker only (no flyctl or Fly.io setup needed)
        - Deployments go to the project maintainer's Fly.io account

Examples:
    getmethatdawg deploy my_agent.py                         # Regular mode
    getmethatdawg deploy my_agent.py --pre-auth              # Pre-auth mode
    getmethatdawg deploy story_agent.py --auto-detect        # Regular with auto-detect
    getmethatdawg deploy story_agent.py --auto-detect --pre-auth  # Pre-auth with auto-detect

Environment Variables:
    GETMETHATDAWG_MODE=pre-auth                              # Default to pre-auth mode
    
The Python file can use the getmethatdawg SDK:
    import getmethatdawg
    
    @getmethatdawg.expose(method="GET", path="/hello")
    def greet(name: str = "world"):
        return {"msg": f"Hello {name}"}

OR with auto-detection, just write regular Python functions:
    def greet(name: str = "world"):
        return {"msg": f"Hello {name}"}

EOF
}

# Show version
show_version() {
    echo "getmethatdawg version 0.0.1"
    echo "Zero-config deploy for Python agents"
    echo "Supports both regular and pre-authenticated modes"
}

# Deploy function using regular flyctl mode
deploy_python_file_regular() {
    local python_file="$1"
    local auto_detect_arg="${2:-}"
    local abs_python_file="$(realpath "$python_file")"
    
    # Validate input file
    if [[ ! -f "$abs_python_file" ]]; then
        log_error "File '$python_file' not found"
        exit 1
    fi
    
    if [[ ! "$abs_python_file" =~ \.py$ ]]; then
        log_error "File '$python_file' is not a Python file"
        exit 1
    fi
    
    log_info "Deploying $python_file (regular mode - using flyctl)..."
    
    # Interactive setup for missing files
    local source_dir="$(dirname "$abs_python_file")"
    prompt_create_requirements "$source_dir" "$abs_python_file"
    prompt_create_env "$source_dir"
    
    # Preview endpoints if using auto-detect
    preview_endpoints "$abs_python_file" "$auto_detect_arg"
    
    # Create temporary directory for build output
    local temp_dir="$(mktemp -d)"
    local output_dir="$temp_dir/out"
    mkdir -p "$output_dir"
    
    # Cleanup function
    cleanup() {
        if [[ -n "${temp_dir:-}" ]] && [[ -d "${temp_dir:-}" ]]; then
        rm -rf "$temp_dir"
        fi
    }
    trap cleanup EXIT
    
    # Use the builder container to process the Python file
    log_info "Analyzing Python file..."
    
    # Check if getmethatdawg/builder image exists, if not provide instructions
    if ! docker image inspect getmethatdawg/builder:latest &> /dev/null; then
        log_warning "Builder image 'getmethatdawg/builder:latest' not found."
        log_info "Building getmethatdawg/builder image..."
        
        # Build the builder image
        docker build -t getmethatdawg/builder:latest -f - "$GETMETHATDAWG_HOME" << 'EOF'
FROM python:3.11-slim

WORKDIR /opt/getmethatdawg

# Copy the getmethatdawg-sdk
COPY getmethatdawg-sdk/ ./getmethatdawg-sdk/

# Install getmethatdawg-sdk
RUN cd getmethatdawg-sdk && pip install -e .

# Copy libexec
COPY libexec/ ./libexec/

# Set up the entry point
COPY bin/getmethatdawg-builder /opt/getmethatdawg/bin/
RUN chmod +x /opt/getmethatdawg/bin/getmethatdawg-builder

ENV PATH="/opt/getmethatdawg/bin:$PATH"

ENTRYPOINT ["/opt/getmethatdawg/bin/getmethatdawg-builder"]
EOF
    fi
    
    # Run the builder container
    log_info "Building deployment artifacts..."
    
    # Check if auto-detect flag is passed
    auto_detect_flag=""
    if [[ "$auto_detect_arg" == "--auto-detect" ]]; then
        auto_detect_flag="--auto-detect"
        log_info "Auto-detection mode enabled"
    fi
    
    # Check if there's a requirements.txt file in the same directory
    local source_dir="$(dirname "$abs_python_file")"
    local requirements_file="$source_dir/requirements.txt"
    local env_file="$source_dir/.env"
    local docker_volumes="-v $abs_python_file:/tmp/source.py:ro -v $output_dir:/tmp/out"
    
    if [[ -f "$requirements_file" ]]; then
        log_info "Found custom requirements.txt, including in deployment"
        docker_volumes="$docker_volumes -v $requirements_file:/tmp/requirements.txt:ro"
    fi
    
    if [[ -f "$env_file" ]]; then
        log_info "Found .env file, including for secrets management"
        docker_volumes="$docker_volumes -v $env_file:/tmp/.env:ro"
    fi
    
    docker run --rm \
        $docker_volumes \
        getmethatdawg/builder:latest /tmp/source.py "$(basename "$python_file" .py)" $auto_detect_flag
    
    # Check if build was successful
    if [[ ! -f "$output_dir/flask_app.py" ]]; then
        log_error "Build failed - no Flask app generated"
        exit 1
    fi
    
    log_success "Built container artifacts"
    
    # Deploy to Fly.io
    log_info "Deploying to Fly.io..."
    
    # Change to output directory for deployment
    cd "$output_dir"
    
    # Check if fly app exists, if not create it
    local app_name="$(basename "$python_file" .py | tr '_' '-')"
    
    if ! flyctl apps list | grep -q "$app_name"; then
        log_info "Creating new Fly.io app: $app_name"
        flyctl apps create "$app_name" --generate-name
    fi
    
    # Deploy the app (check for secrets script first)
    if [[ -f "deploy-with-secrets.sh" ]]; then
        log_info "Deploying with secrets management..."
        chmod +x deploy-with-secrets.sh
        ./deploy-with-secrets.sh
    else
        log_info "Deploying without secrets..."
        flyctl deploy --remote-only --config fly.toml --dockerfile Dockerfile
    fi
    
    # Get the app URL
    local app_url="$(flyctl apps list | grep "$app_name" | awk '{print $2}' | head -1)"
    if [[ -z "$app_url" ]]; then
        app_url="$app_name.fly.dev"
    fi
    
    log_success "Pushed to Fly.io"
    echo -e "${GREEN}üåê https://$app_url${NC}"
    
    # Show endpoints
    log_info "Available endpoints:"
    echo "  GET  https://$app_url/ (health check)"
    
    # Parse endpoints from generated flask app (basic parsing)
    if [[ -f "$output_dir/flask_app.py" ]]; then
        grep -E "@app\.route\(" "$output_dir/flask_app.py" | while read -r line; do
            if [[ "$line" =~ @app\.route\(\'([^\']+)\',.*methods=\[\'([^\']+)\' ]]; then
                local path="${BASH_REMATCH[1]}"
                local method="${BASH_REMATCH[2]}"
                echo -e "  ${method}  https://$app_url$path"
            fi
        done
    fi
}

# Deploy function using pre-authenticated container
deploy_python_file_preauth() {
    local python_file="$1"
    local auto_detect_arg="${2:-}"
    local abs_python_file="$(realpath "$python_file")"
    
    # Validate input file
    if [[ ! -f "$abs_python_file" ]]; then
        log_error "File '$python_file' not found"
        exit 1
    fi
    
    if [[ ! "$abs_python_file" =~ \.py$ ]]; then
        log_error "File '$python_file' is not a Python file"
        exit 1
    fi
    
    log_info "Deploying $python_file (pre-authenticated mode - no flyctl needed)..."
    
    # Interactive setup for missing files
    local source_dir="$(dirname "$abs_python_file")"
    prompt_create_requirements "$source_dir" "$abs_python_file"
    prompt_create_env "$source_dir"
    
    # Preview endpoints if using auto-detect
    preview_endpoints "$abs_python_file" "$auto_detect_arg"
    
    # Create temporary directory for build output
    local temp_dir="$(mktemp -d)"
    local output_dir="$temp_dir/out"
    mkdir -p "$output_dir"
    
    # Cleanup function
    cleanup() {
        if [[ -n "${temp_dir:-}" ]] && [[ -d "${temp_dir:-}" ]]; then
            rm -rf "$temp_dir"
        fi
    }
    trap cleanup EXIT
    
    # Use the pre-authenticated builder container
    log_info "Using pre-authenticated builder container..."
    
    # Container image (prioritize GitHub Container Registry)
    local builder_image="ghcr.io/dwij1704/getmethatdawg-builder:authenticated"
    
    # Check if we need to pull the latest image
    if ! docker image inspect "$builder_image" &> /dev/null; then
        log_info "Pulling pre-authenticated builder container..."
        if ! docker pull "$builder_image" 2>/dev/null; then
            log_warning "Failed to pull from GitHub Container Registry, trying Docker Hub..."
            builder_image="getmethatdawg/builder:authenticated"
            if ! docker pull "$builder_image" 2>/dev/null; then
                log_error "Failed to pull pre-authenticated container. Please ensure it's available."
                log_info "To use pre-auth mode, the project maintainer needs to build and push the authenticated container."
                log_info "Falling back to regular mode..."
                deploy_python_file_regular "$python_file" "$auto_detect_arg"
                return
            fi
        fi
    fi
    
    # Check if auto-detect flag is passed
    auto_detect_flag=""
    if [[ "$auto_detect_arg" == "--auto-detect" ]]; then
        auto_detect_flag="--auto-detect"
        log_info "Auto-detection mode enabled"
    fi
    
    # Check for additional files in the same directory
    local source_dir="$(dirname "$abs_python_file")"
    local requirements_file="$source_dir/requirements.txt"
    local env_file="$source_dir/.env"
    local docker_volumes="-v $abs_python_file:/tmp/source.py:ro -v $output_dir:/tmp/out"
    
    if [[ -f "$requirements_file" ]]; then
        log_info "Found custom requirements.txt, including in deployment"
        docker_volumes="$docker_volumes -v $requirements_file:/tmp/requirements.txt:ro"
    fi
    
    if [[ -f "$env_file" ]]; then
        log_info "Found .env file, including for secrets management"
        docker_volumes="$docker_volumes -v $env_file:/tmp/.env:ro"
    fi
    
    # Run the pre-authenticated builder container
    log_info "Building and deploying with pre-authenticated container..."
    
    # Create a deployment script that will run inside the container
    local deploy_script="$output_dir/deploy-script.sh"
    cat > "$deploy_script" << 'EOF'
#!/bin/bash
set -euo pipefail

echo "üîß Building deployment artifacts..."
getmethatdawg-builder /tmp/source.py "$1" $2

echo "üìÅ Changing to build output directory..."
cd /tmp/out

echo "üöÄ Starting deployment to Fly.io..."

# Get app name from the parameter
APP_NAME="$1"

# Check if fly app exists, if not create it
if ! flyctl apps list | grep -q "$APP_NAME"; then
    echo "üì± Creating new Fly.io app: $APP_NAME"
    flyctl apps create "$APP_NAME" --generate-name || true
fi

# Deploy the app (check for secrets script first)
if [[ -f "deploy-with-secrets.sh" ]]; then
    echo "üîê Deploying with secrets management..."
    chmod +x deploy-with-secrets.sh
    ./deploy-with-secrets.sh
else
    echo "üöÄ Deploying without secrets..."
    flyctl deploy --remote-only --config fly.toml --dockerfile Dockerfile
fi

echo "‚úÖ Deployment completed successfully!"

# Get the app URL
APP_URL=$(flyctl status --app "$APP_NAME" | grep "Hostname" | awk '{print $2}' | head -1 || echo "$APP_NAME.fly.dev")
echo "üåê App URL: https://$APP_URL"

# Show endpoints
echo "üì° Available endpoints:"
echo "  GET  https://$APP_URL/ (health check)"

# Parse endpoints from generated flask app (basic parsing)
if [[ -f "/tmp/out/flask_app.py" ]]; then
    grep -E "@app\.route\(" "/tmp/out/flask_app.py" | while read -r line; do
        if [[ "$line" =~ @app\.route\(\'([^\']+)\',.*methods=\[\'([^\']+)\' ]]; then
            path="${BASH_REMATCH[1]}"
            method="${BASH_REMATCH[2]}"
            echo "  ${method}  https://$APP_URL$path"
        fi
    done
fi
EOF
    chmod +x "$deploy_script"
    
    # Run the container with the deployment script, streaming output in real-time
    if docker run --rm \
        $docker_volumes \
        -v "$deploy_script:/tmp/deploy.sh:ro" \
        "$builder_image" \
        /tmp/deploy.sh "$(basename "$python_file" .py | tr '_' '-')" "$auto_detect_flag"
    then
        log_success "üéâ Deployment completed successfully!"
    else
        log_error "‚ùå Deployment failed"
        exit 1
    fi
}

# Parse arguments and determine mode
parse_args_and_deploy() {
    local python_file=""
    local auto_detect=""
    local pre_auth=""
    
    # Parse arguments
    for arg in "$@"; do
        case "$arg" in
            --auto-detect)
                auto_detect="--auto-detect"
                ;;
            --pre-auth)
                pre_auth="yes"
                ;;
            -*)
                log_error "Unknown option: $arg"
                show_usage
                exit 1
                ;;
            *)
                if [[ -z "$python_file" ]]; then
                    python_file="$arg"
                else
                    log_error "Multiple Python files specified: $python_file and $arg"
                    exit 1
                fi
                ;;
        esac
    done
    
    if [[ -z "$python_file" ]]; then
        log_error "Please specify a Python file to deploy"
        show_usage
        exit 1
    fi
    
    # Check environment variable for default mode
    if [[ -z "$pre_auth" && "${GETMETHATDAWG_MODE:-}" == "pre-auth" ]]; then
        pre_auth="yes"
        log_info "Using pre-auth mode (set by GETMETHATDAWG_MODE environment variable)"
    fi
    
    # Deploy based on mode
    if [[ "$pre_auth" == "yes" ]]; then
        check_dependencies_preauth
        deploy_python_file_preauth "$python_file" "$auto_detect"
    else
        check_dependencies_regular
        deploy_python_file_regular "$python_file" "$auto_detect"
    fi
}

# Main function
main() {
    case "${1:-}" in
        deploy)
            shift
            parse_args_and_deploy "$@"
            ;;
        --help|-h)
            show_usage
            ;;
        --version|-v)
            show_version
            ;;
        "")
            log_error "No command specified"
            show_usage
            exit 1
            ;;
        *)
            log_error "Unknown command: $1"
            show_usage
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@" 